### *#93* execution context
Execution steps
 1. Creation of global execution context for top level code (You don’t want to call function if you don’t use them)
 2. Execution of top level code ( processor executing cpu code)
 3. Execution and waiting for callbacks. For each function call, an execution context is created 

Execution context ( concept )
- Environment where code is executed. Store all the necessary information for the code to be executed. JavaScript always run in a execution context 
- All execution context of function create the call stack
- Created before execution code

What is inside an execution context ?
- a variable environment : containing all the variable, functions and arguments objects of the called function 
- A scope chain : references to variables outside the current function
- the « this keyword »

	The arrow functions does not have this keyword and arguments objects
![[image1.jpeg]]

The call stack
- Place where all execution context are stack on top of each other , the top being the one executed 
- JavaScript can only execute one function at a time because it is a single threaded language
- 
![[image2.jpeg]]

### *#94* Scope and scope chain

Introduction
- Scope is a space or environment in which a certain variable is declared ( global, function or block scope )
- Scope of a variable is where the variable can be accessed 
- Scoping is how the program variable and function are organized 
- JavaScript uses lexical scoping, which means variables is controlled by placement of functions and blocks in the code

3 types of scope
- Global scope : outside of any function or block, variables accessible everywhere. Variable of the global scope are called global variables 
- Function scope or local scope : variables are accessible only inside the function 
- ES6 Bloc scope (if block, for loop block) : let and const variables, as well as functions ( in strict mode ) are only accessible inside the block too. var variables are accessible outside the block 
==Is c++ block scoped ??==

The scope chain
- Child scope can access parent scope variables ( variable lookup ) and not the contrary
- A function declared inside a function can access the first function variables and also the global scope ( the functions declared in global scope have access to global variables )
- A function called but not declared inside another function cannot access the first function variables 
- Bloc also create scope chain but only with let and const variables ( not var ) 

Call stack scope chain
- call stack is the order where function are called
- Scope related of the boundaries of the variables, but does not follow call stack order for accessing variables
### *#95 scope in practice*

Scope chains
- A function declared in another function can only be accessible in the scope of the outer level function. If we try to call it from outside it won’t work. Function are treated like objects 
- Object lookup is a one way street from inner to outer
- var variables ignore bloc scope but are still bound to function scope
- Function respect bloc scope, but only in strict mode
- If two variables are defined in two scopes, the one of the most inner scope will be used, because JavaScript check the current scope before checking the outer scope
- You can redefine an existing variable into a new block. If there is redefinition, a new variable is created in the scope, if not, the lookup will return the original variable

### *#96-97 Hoysting and TDZ**
- Make variables accessible before they are declared 
- happens during the creation of global execution context
Objects and hoisting :
	- Function declarations are hoisted so you can use a function before its declaration
	- var variables are hoisted but set as undefined not as their value. Their declaration will declare a property on the window object
	- Let and const are not hoisted ( but placed in temporal dead zone)
	- function expression and arrows can be hoisted or not depending if you declare them with var or let or const

Temporal dead zone :
- It is the zone where JavaScript knows that the variable will eventually be initialized but it is not initialized yet
- It starts at the beginning of the scope of the variable until the declaration of variable
- It allows for let and const variable to throw an error instead of being set to initialized like var variables
- also makes impossible to have two declaration of const variables

Best practices :
Declare variables at the top of the code
Declare function first and use them only after declaration
Never use var ( to not risk undefined variables)

### *#98-99 the this keyword*

The this keyword 
- The this keyword is a special variable created for every execution context and point to the owner of the function
- The this keyword is not static and is only assigned when the function is called
- 

Different this calls : 
- For a method : this is the object calling the method
`Const jonas = { age : 23, calcAge : function(){return 2027- this.age}}
Jonas.calcAge()
- For a simple function call : this is undefined ( in strict mode ) ( global object in not strict mode )
- For a arrow function : no this keyword : this becomes the this of the outer scope of the arrow function
- event listener : this is the DOM element that the handler is attached to

- this in the main code return the global object window

### *100 Regular and arrow function*

-this in arrow function. Points to the outter scope, so if defined in global scope will point to window object

-var create properties on the global object
var firstName = 'Matilda';
greet: () => console.log(`Hey ${this.firstName}`)
will return Hey matilda

this inside a function inside a method
-in a function defined inside a method of an object, this will still return undefined as it is a simple function call
-(pre ES6) to prevent this we can create a variable self (or that) set to this outside the function, and then use self in the function
const self = this
- (ES6) arrow function. Using arrow function (that don't have this), this becomes the this of the upper scope so the this of the method

arguments keyword
-return an array of the arguments we passed in the function
-even if we have more arguments than the initial number of argument it will work 
const addExpr = function(a,b)
addExpr(5,6,7,8) //arguments object will hold (5,6,7,8)
- arrow functions don't have arguments keyword like no this keyword

### *101/102/103 Memory management*

memory is automatically managed by javascript

memory lifecycle : 
1 - allocate memory
- whenever we assign value to a new variable, the engine automatically allocates piece of memory to store that value
- primitives are stored in the call stack (in the execution context where they are created)
- object are stored in the heap
- object references are stored in the call stack

2 - use memory
When we read, write and update the value stored

3 - Release memory
Deleted when not used in anymore
- in the call stack, variables are deleted when their execution context is popped off of the call stack. global variables are never deleted until the program finishes
- for objects in the heap, garbage collection is used by the engine
- for garbage collection "mark and sweep" algorithm is used. 
1 - Mark
Every objects reachable from a root (global execution context, function context, event listener, closure) is marked as alive. example : object in global execution context will never be deleted
If object is not reachable, it is unmarked. 
2 - Sweep 
Delete un-marked object and free its allocated memory 


Object references
- when you create a function, the execution context will store the primitives inside. But for object, the execution context will store a reference to the object and not the object itself. The object itself will be in the heap.
- if we copy an object, we copy the reference of the object but not the object itself. So modify the the copy will also modify the original
- if we copy a primitive, we can modify the new copy without consequences on the original variable
- passing an object in a function will be passing it by references


Shallow copy vs Deep copy for creating new object

-Shallow copy
means that only the primitves are new, the copied objects point to the same as the original
-const jessicaCopy = {...jessica2}; // shallow copy
- {} : create a new object
- ... : copy all the properties of jessica2
-if you modify the jessicaCopy it will not modify the original jessica2 object

-Deep copy
const deepJessicaCopy = structuredClone(jessica2) //deep
new copy for everything even objects 

Memory leak
- object not needed by our application still in the heap. Can happen when we set up a timer or event listener referencing an object





